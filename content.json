{"meta":{"title":"mirindalover的博客","subtitle":"you see see you one day day","description":"还是有个自己的博客好","author":"mirindalover","url":"https://mirindalover.github.io","root":"/"},"pages":[{"title":"tags","date":"19/06/2019","updated":"19/06/2019","comments":true,"path":"tags/index.html","permalink":"https://mirindalover.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android-MVP","slug":"Android-MVP","date":"19/07/2019","updated":"19/07/2019","comments":true,"path":"elite/Android-MVP.html","link":"","permalink":"https://mirindalover.github.io/elite/Android-MVP.html","excerpt":"","text":"MVP介绍MVP设计模式分成了View、Presenter、Model层，不同于原来的MVC，view中不在存放业务逻辑-只是展示页面，而由Presenter来统筹全局-处理逻辑介绍几个官方MVP的写法官方Demo优秀实践MVP与Lifecycle结合 MVP分析官方MVP建议使用Activity里面创建Presenter,View使用Fragment，一图胜千言 实际中，我们的view可以是Activity或者Fragment,完全不需要一个Activity来嵌套一层view ####MVP模式封装 View首先View接口，我们没有特定的方法需要实现，但是为了配合Presenter，我们的IView是个空接口。后面view只是简单的实现即可 12public interface IMvpView&#123;&#125; PresenterPresenter中需要与View绑定，同时还需要知道view的生命周期-至少知道attach和detach 123456789101112public interface IMvpPresenter&lt;V extends IMvpView&gt; &#123; /** * 初始化Presenter时,用于presenter与view绑定 */ void onBind(V view); void onViewAttach(); void onViewDetach();&#125; Presenter的基类Presenter中公共的，我们会做与view的绑定和解绑 12345678910111213141516171819202122232425262728public abstract class MvpPresenter&lt;V extends IMvpView&gt; implements IMvpPresenter&lt;V&gt; &#123; protected V mView; protected Context mContext; @Override public void onBind(V view) &#123; mView = view; if (view instanceof Fragment) &#123; mContext = ((Fragment) view).getContext(); &#125; else if (view instanceof Activity) &#123; mContext = (Activity) view; &#125; else if (view instanceof View) &#123; mContext = ((View) view).getContext(); &#125; &#125; @Override public void onViewAttach() &#123; &#125; @Override public void onViewDetach() &#123; mView = null; &#125;&#125; 在detach时吧mView置空，会导致调用mView出现空指针问题 这里我想过使用生成代码的方式判断mView的值,但是一直无法完美的实现。最后使用了空对象设计模式来实现 12345678910private V mView;protected V getView() &#123; if (mView == null) &#123; return createDummyView(); &#125; return mView; &#125;protected abstract V createDummyView(); Helper类View与Presenter的绑定,可以简单的在创建presenter的时候手动调用，如 12#View(Fragment|Activity)new XPresenter().onBind(this); 但是不乏我们忘记，所以可以写一个帮助类来完成 12345678910public class MvpLifecycleHelper &#123; /** * 把View和Presenter关联起来 */ public static &lt;V extends IMvpView, P extends IMvpPresenter&lt;? super V&gt;&gt; P from(V view, P presenter) &#123; presenter.onBind(view); return presenter; &#125;&#125; 这里写泛型的时候出现了一些小问题，可以查看另一篇博客这样我们绑定的时候使用如下 1MvpLifecycleHelper.from(this,new LoginPresenter()); 到此我们的MVP的简单封装已经完成。但是现在presenter的周期还是需要view手动去调用的，这样还是很不友好 结合Lifecycle其实我们要做的也很简单，只需要在onBind中添加presenter给lifecycle，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class PresenterLifecycle&lt;V extends IMvpView&gt; extends MvpPresenter&lt;V&gt; implements LifecycleObserver, IPresenterLifecycle&lt;V&gt; &#123; @Override public void onBind(V view) &#123; super.onBind(view); if (view instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) view).getLifecycle(); //会立马调用对应的监听 lifecycle.addObserver(this); if (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123; this.onViewAttach(); &#125; &#125; &#125; @Override @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) public void onViewAttach() &#123; mLifecycleSubject.onNext(Lifecycle.Event.ON_CREATE); &#125; @Override @OnLifecycleEvent(Lifecycle.Event.ON_START) public void onStart() &#123; mLifecycleSubject.onNext(Lifecycle.Event.ON_START); &#125; @Override @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void onResume() &#123; mLifecycleSubject.onNext(Lifecycle.Event.ON_RESUME); &#125; @Override @OnLifecycleEvent(Lifecycle.Event.ON_STOP) public void onStop() &#123; mLifecycleSubject.onNext(Lifecycle.Event.ON_STOP); &#125; @Override @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) public void onViewDetach() &#123; mLifecycleSubject.onNext(Lifecycle.Event.ON_DESTROY); super.onViewDetach(); &#125;&#125; 由于addObserver时，会调用一次对应的周期，所以我们可以完全不用手动调用onViewAttach()。唯一存在的可能是我们在onResume才绑定presenter(这种可能很低)，所以添加了一下周期判断 至此整个封装完成，源码已经同步到github，可下载使用","author":"砖头","categories":[{"name":"精华","slug":"elite","permalink":"https://mirindalover.github.io/categories/elite/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mirindalover.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://mirindalover.github.io/tags/MVP/"},{"name":"Lifecycle","slug":"Lifecycle","permalink":"https://mirindalover.github.io/tags/Lifecycle/"}]},{"title":"泛型日常使用","slug":"泛型日常使用","date":"11/07/2019","updated":"11/07/2019","comments":true,"path":"notes/泛型日常使用.html","link":"","permalink":"https://mirindalover.github.io/notes/泛型日常使用.html","excerpt":"","text":"前言最近在封装MVP模式时,由于Presenter与View的base接口用了泛型进行限制,将View与Presenter关联起来时导致编译无法通过。因此唠叨一番 场景直接上base的view和presenter,同时看看大家能解决关联的问题吗 123#Viewpublic interface IMvpView&#123;&#125; 1234567891011#Presenterpublic interface IMvpPresenter&lt;V extends IMvpView&gt; &#123; /** * 初始化Presenter时,用于presenter与view绑定 */ void onBind(V view); void onViewAttach(); void onViewDetach();&#125; 现在要写一个帮助方法来讲View和Presenter结合起来,即调用onBind方法 最简单的莫过于,直接调用 123public void LoginView()&#123; new LoginPresenter().onBind(this);&#125; 但是那岂不是所有的view里面创建presenter后接着调用onBind方法，因此写了下面的方法 12345#帮助类里public static &lt;V extends IMvpView, P extends IMvpPresenter&lt;V&gt;&gt; P from(V view, P presenter) &#123; presenter.onBind(view); return presenter;&#125; 看方法貌似没有啥问题,但是当你使用的是会报错的。要求presenter的泛型必须是LoginView类。看一下我们写的确实是有问题，V当成泛型直接给了IMvpPresenter。那我们要怎么写才能避免这种报错呢我采用大多数问题都可以通过引入第三方的方式来解决(类、变量等)的原则，所以写出了下面的方法 1234public static &lt;T extends IMvpView, P extends IMvpPresenter&lt;T&gt;, V extends T&gt; P from(V view, P presenter) &#123; //需要使用T作为中介 presenter.onBind(view); return presenter;&#125; 问题解决，但是下面介绍一种其他方法,使用通配符 泛型的一些知识这里我有一些总结,可以大体看一下。泛型其中通配符用?表示，由于他的类型表示一组未知的类型,所以我们即使写成IMvpPresenter&lt;?&gt;也不会报错。我们利用这一点，写出下面的方法 1234public static &lt;V extends IMvpView, P extends IMvpPresenter&lt;? super V&gt;&gt; P from(V view, P presenter) &#123; presenter.onBind(view); return presenter;&#125; 通配符虽然可以绕过声明的报错，但是使用时还是要遵循泛型的边界的,所以这里用到了super V。同时限制V的类型 本文只是记录日常开发遇到的小问题，没有深入研究，对此感到抱歉，后期会对泛型进行详细研究","author":"砖头","categories":[{"name":"随笔","slug":"notes","permalink":"https://mirindalover.github.io/categories/notes/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://mirindalover.github.io/tags/Java/"},{"name":"杂谈","slug":"talk","permalink":"https://mirindalover.github.io/tags/talk/"}]},{"title":"RxJava初探","slug":"RxJava初探","date":"05/07/2019","updated":"11/07/2019","comments":true,"path":"elite/RxJava初探.html","link":"","permalink":"https://mirindalover.github.io/elite/RxJava初探.html","excerpt":"","text":"前言本文使用RxJava2.x，仅作为入门笔记，后续持续更新。本文所有代码使用junit测试可直接运行 友情链接官网操作符入门博客 集成 123//RxJava+RxAndroidimplementation \"io.reactivex.rxjava2:rxjava:2.2.10\"implementation 'io.reactivex.rxjava2:rxandroid:2.1.1' 简介RxJava2.x有2种观察模式: Observable-&gt;Observer不支持背压 Flowable-&gt;Subscriber支持背压 被观察者也叫做上游,下游即为观察者被观察者可以想象成通过流的形式发送数据 HelloWorld12345678910111213141516171819202122232425262728293031323334@Testpublic void hello() &#123; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onNext(\"4\"); emitter.onComplete(); emitter.onNext(\"5\"); &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;);&#125; 这里用的是Observer，如果我们只关心onNext事件,可以使用Consumer来替换Observer emitter用来发送流 Disposable 可以切断上游和下游的联系,但是上游还会发送事件线程切换 subscribeOn()指定上游发送事件的线程(多次指定，只有第一次有效) observeOn()下游接受事件的线程(可以多次切换,与doOnNext对应)12345678910111213141516171819202122232425262728293031323334@Testpublic void threadChange() &#123; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onNext(\"4\"); emitter.onComplete(); emitter.onNext(\"5\"); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(\"doOnNext: Thread = \" + Thread.currentThread() + \"value =\" + s); &#125; &#125;) .observeOn(Schedulers.newThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(\"subscribe: Thread = \" + Thread.currentThread() + \"value =\" + s); &#125; &#125;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 流的转化 map-对每个流操作后继续流出(改变每个流的输入继续当输入。可改变输入的类型和值) flatMap-对每个流可进行转换,转换为新的Observable(根据输入重新开始流，不保证顺序) concatMap-与flatMap类似,保证顺序1234567891011121314151617181920212223242526272829@Testpublic void mapTest() &#123; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onNext(\"4\"); emitter.onComplete(); emitter.onNext(\"5\"); &#125; &#125;).map(new Function&lt;String, String&gt;() &#123; @Override public String apply(String s) throws Exception &#123; return s + \"+map\"; &#125; &#125;).flatMap(new Function&lt;String, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(String s) throws Exception &#123; return Observable.just(s + \"+flatMap\"); &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; System.out.println(\"subscribe: Thread = \" + Thread.currentThread() + \"value =\" + s); &#125; &#125;); &#125; 流的组合 zip-将2个流组合起来 必须拿到2个流才能组合，所以下游收到的流次数即为发送最少的上游的次数 一个流结束,整个过程结束同时上游也会结束 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Testpublic void zipTest() &#123; Observable.zip(Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"1\"); emitter.onNext(\"2\"); emitter.onNext(\"3\"); emitter.onNext(\"4\"); emitter.onNext(\"5\"); emitter.onComplete(); emitter.onNext(\"6\"); &#125; &#125;).subscribeOn(Schedulers.io()), Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; emitter.onNext(\"A\"); Thread.sleep(10); emitter.onNext(\"B\"); Thread.sleep(10); emitter.onNext(\"C\"); Thread.sleep(10); emitter.onNext(\"D\"); Thread.sleep(10); emitter.onComplete(); Thread.sleep(10); emitter.onNext(\"E\"); &#125; &#125;), new BiFunction&lt;String, String, String&gt;() &#123; @Override public String apply(String s, String s2) throws Exception &#123; return s + \"-\" + s2; &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;);&#125; 流的过滤我们可以根据条件过滤掉上游的数据,这样上游相当于会丢失一部分数据 filter-对流进行过滤，满足条件可通过(可减少下游压力) sample-周期的去取最近的一次(如果想取周期的第一次可以使用throttleFirst)12345678910111213141516171819202122232425262728293031323334 @Test public void filterTest() &#123; Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; emitter.onNext(i); Thread.sleep(10); &#125; emitter.onComplete(); &#125; &#125;).filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) throws Exception &#123; return integer % 2 == 0; &#125; &#125;)// .throttleFirst(50,TimeUnit.MILLISECONDS) .sample(50, TimeUnit.MILLISECONDS) .observeOn(Schedulers.io()) .subscribeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; System.out.println(integer); &#125; &#125;); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 流的条件运算计算多个观测对象的运算符 TakeUntil-第二个观察对象发出流或者终止后，结束订阅，丢弃观测对象的任何流(不是终止观测对象)12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Testpublic void takeUntilTest() &#123; Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"onNext==\" + i); emitter.onNext(String.valueOf(i)); Thread.sleep(10); &#125; &#125; &#125;).takeUntil(Observable.interval(100, 10, TimeUnit.MILLISECONDS).doOnNext(new Consumer&lt;Long&gt;() &#123; @Override public void accept(Long aLong) throws Exception &#123; System.out.println(aLong); &#125; &#125;)) .subscribeOn(Schedulers.io()) .subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onError(Throwable e) &#123; System.out.println(\"error\" + e); &#125; @Override public void onComplete() &#123; System.out.println(\"complete\"); &#125; &#125;); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; Flowable另一种观察模式是使用Flowable,同时他支持背压。建议只在需要的时候使用,其他情况还是使用Observable先来看例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void backPressureTest() &#123; Flowable.create(new FlowableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception &#123;// System.out.println(Thread.currentThread()); for (int i = 0; i &lt; 128; i++) &#123;// if (emitter.requested() &gt; 0) &#123; emitter.onNext(String.valueOf(i));// &#125; &#125; emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR) .subscribeOn(Schedulers.io())// .observeOn(Schedulers.io()) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123;// System.out.println(Thread.currentThread()); s.request(90); &#125; @Override public void onNext(String s) &#123; System.out.println(s); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"error\" + t); &#125; @Override public void onComplete() &#123; System.out.println(\"onComplete\"); &#125; &#125;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 使用Subscriber来订阅。也可以使用Consumer(但这样其实与用Observable没有什么区别) 与Observable不同的是: 上游可以知道下游的处理能力,来做出相应的策略(FlowableEmitter.requested()即为下游可处理的事件) 上游的流可以存放起来等待下游处理(由bufferSize控制存放的最大量) 其实我们使用的时候关心的核心就是2个：下游的处理能力、上游的缓存最大数量 默认下游的处理能力为0 增加下游处理能力：使用Subscription .request()来增加 减少下游处理能力：当上游发送流即emitter.onNext()时 上游的缓存默认为0 当上游无法缓存时,会走背压策略即BackpressureStrategy即create时的第二个参数 可以通过observeOn指定缓存最大数量,调用但是不指定内部会有默认值128 Subscription和FlowableEmitter这里贴出一个结论(如何得到的结论，以后会进行源码分析) 当不切换线程或者只指定上游的线程即subscribeOn时。Subscription和FlowableEmitter是同一个对象 我们Subscription.request()设置后上游的FlowableEmitter.requested()会立马改变 当上游和下游都指定了线程。Subscription和FlowableEmitter是不同的对象，这里就涉及到下游的处理能力同步给上游的问题 开始上游FlowableEmitter的requested()为128下游Subscription,request()96以后，上游的FlowableEmitter会更新到128即不是实时同步的 后续问题关于背压的后续分析问题： Subscription和FlowableEmitter分别是什么时候赋值的 不同线程的时候Subscription和FlowableEmitter如何同步","author":"砖头","categories":[{"name":"精华","slug":"elite","permalink":"https://mirindalover.github.io/categories/elite/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mirindalover.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://mirindalover.github.io/tags/RxJava/"}]},{"title":"Android单元测试-UI","slug":"Android单元测试-UI","date":"26/06/2019","updated":"05/07/2019","comments":true,"path":"basics/Android单元测试-UI.html","link":"","permalink":"https://mirindalover.github.io/basics/Android单元测试-UI.html","excerpt":"","text":"前言UI单元测试使用官方的Espresso在开发中对于重要的功能可编写单元测试,为防止后期的修改影响功能,每次开发完跑一遍测试即可保证功能的完整性 友情链接官网指南Google官方测试Sample地址本文demoEspresso本文demo使用官网的内容demo内容介绍MainActivity输入框输入文字后 点击change按钮：设置内容到TextView上 点击open按钮：打开一个Activity,同时把内容传递过去,用来显示到TextView上Espresso依赖12345678dependencies &#123; //test testImplementation 'junit:junit:4.12' androidTestImplementation 'androidx.test:runner:1.1.0' androidTestImplementation 'androidx.test:rules:1.1.0' //espresso androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'&#125; 环境依赖12345android &#123; defaultConfig &#123; testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" &#125;&#125; 添加单元测试任务 Run&gt;Edit Configurations 添加一个Android Instrumented Tests 选择对应的module 选择真机或者模拟器 如果选择真机：关闭开发者选项&gt;绘画&gt;窗口动画缩放;过滤动画缩放;动画程序时长缩放编写单元测试我们先验证应用是否开启了,直接验证是否有Hello World12345678910111213@RunWith(AndroidJUnit4.class)@LargeTestpublic class ChangeTextBehaviorTest &#123; @Rule public ActivityTestRule&lt;MainActivity&gt; activityRule = new ActivityTestRule&lt;&gt;(MainActivity.class, false, true); @Test public void listGoesOverTheFold() &#123; onView(withText(\"Hello world!\")).check(matches(isDisplayed())); &#125;&#125; 其中@LargeTest可根据自己情况来改变,具体见下图 @Rule定义测试启动的Activity @Test来测试方法 常用的Espresso的API onView 查找元素;onData() 查找AdapterView元素 withText()通过文字查找 withId()通过id查找 allOf()匹配多个条件-org.hamcrest.Matchers perform 执行操作 click点击 typeText点击并且输入一个值;最好结合closeSoftKeyboard scrollTo滑动-onView必须是ScrollView pressKey按键 clearText清空view的文字 check 验证结果 matches 所有的API可见官方给出的图示 如果我们启动的Activity不是MainActivity,而且需要intent传值,则可以使用下面的代码 1234567891011121314151617181920212223@RunWith(AndroidJUnit4.class)@LargeTestpublic class TextShowTextActivity &#123; private static final String MESSAGE = \"12312\"; @Rule public ActivityTestRule&lt;ShowTextActivity&gt; activityRule = new ActivityTestRule&lt;ShowTextActivity&gt;(ShowTextActivity.class, false, true)&#123; @Override protected Intent getActivityIntent() &#123; Intent result = new Intent(); result.putExtra(ShowTextActivity.KEY_EXTRA_MESSAGE, MESSAGE); return result; &#125; &#125;; @Test public void listGoesOverTheFold() &#123; onView(withText(MESSAGE)).check(matches(isDisplayed())); &#125;&#125; 使用intent单独测试Activity即可以获取即将打开Activity的intent来检查一个Activity的完成性 官方指南 依赖 1234dependencies &#123; //intent androidTestImplementation 'androidx.test.espresso:espresso-intents:3.1.0'&#125; 改变Rule 12@Rulepublic IntentsTestRule&lt;MyActivity&gt; intentsTestRule = new IntentsTestRule&lt;&gt;(MyActivity.class); 测试代码如下 1234567891011121314151617181920212223242526272829@RunWith(JUnit4.class)@LargeTestpublic class ChangePageBehaviorTest &#123; private static final String MESSAGE = \"This is a test\"; private static final String PACKAGE_NAME = \"com.mlc.android_test\"; @Rule public IntentsTestRule&lt;MainActivity&gt; intentsRule = new IntentsTestRule&lt;&gt;(MainActivity.class); @Test public void verifyMessageSentToMessageActivity() &#123; // Types a message into a EditText element. onView(withId(R.id.editTextUserInput)) .perform(typeText(MESSAGE), closeSoftKeyboard()); // Clicks a button to send the message to another // activity through an explicit intent. onView(withId(R.id.activityChangeTextBtn)).perform(click()); // Verifies that the DisplayMessageActivity received an intent // with the correct package name and message. intended(allOf( hasComponent(hasShortClassName(\".ShowTextActivity\")), toPackage(PACKAGE_NAME), hasExtra(ShowTextActivity.KEY_EXTRA_MESSAGE, MESSAGE))); &#125;&#125; UiAutomatorUIAutomator主要用于多个应用之间的测试由于目前没有好的例子,Demo中也只是使用了官方的用例,这里只给出链接 官方指南测试原理浅析首先我们需要了解Activity的开启流程,可以参考我总结的Activity启动流程Activity需要通过Instrumentation来与系统交互的,单元测试中其实也一样，通过它来开启Activity我们从ActivityTestRule来作为入口12345678910111213141516171819#ActivityTestRule/** * Launches the Activity under test. */ public T launchActivity(@Nullable Intent startIntent) &#123; //... if (null == startIntent) &#123; startIntent = getActivityIntent(); if (null == startIntent) &#123; startIntent = new Intent(Intent.ACTION_MAIN); &#125; &#125; if (null == startIntent.getComponent()) &#123; startIntent.setClassName(targetPackage, activityClass.getName()); &#125; T hardActivityRef = activityClass.cast(instrumentation.startActivitySync(startIntent)); //... return hardActivityRef; &#125; 启动Activity是通过launchActivity()方法来启动，看做了什么操作: 设置intent 使用instrumentation.startActivitySync()开启Activity到这里我们已经清楚单元测试也与普通的应用一样，是用instrumentation来开启Activity题外话其实这个instrumentation是MonitoringInstrumentation12345678910111213141516171819202122232425262728293031323334353637383940#MonitoringInstrumentation @Override public Activity startActivitySync(final Intent intent) &#123; checkNotMainThread(); Future&lt;Activity&gt; startedActivity = executorService.submit( new Callable&lt;Activity&gt;() &#123; @Override public Activity call() &#123; return MonitoringInstrumentation.super.startActivitySync(intent); &#125; &#125;); try &#123; return startedActivity.get(START_ACTIVITY_TIMEOUT_SECONDS, TimeUnit.SECONDS); &#125; catch (TimeoutException te) &#123; dumpThreadStateToOutputs(\"ThreadState-startActivityTimeout.txt\"); startedActivity.cancel(true); throw new RuntimeException( String.format( \"Could not launch intent %s within %s seconds.\" + \" Perhaps the main thread has not gone idle within a reasonable amount of \" + \"time? There could be an animation or something constantly repainting the \" + \"screen. Or the activity is doing network calls on creation? See the \" + \"threaddump logs. For your reference the last time the event queue was idle \" + \"before your activity launch request was %s and now the last time the queue \" + \"went idle was: %s. If these numbers are the same your activity might be \" + \"hogging the event queue.\", intent, START_ACTIVITY_TIMEOUT_SECONDS, lastIdleTimeBeforeLaunch, lastIdleTime.get())); &#125; catch (ExecutionException ee) &#123; throw new RuntimeException(\"Could not launch activity\", ee.getCause()); &#125; catch (InterruptedException ie) &#123; Thread.currentThread().interrupt(); throw new RuntimeException(\"interrupted\", ie); &#125; &#125; 我们看到是通过线程池来开启，获取Future后，设置了超时时间45s。在我们设置activity有问题时经常出现 Tips 真机运行可能需要安装应用后开启手机允许后台弹出界面权限","author":"砖头","categories":[{"name":"基础","slug":"basics","permalink":"https://mirindalover.github.io/categories/basics/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://mirindalover.github.io/tags/Android/"},{"name":"单元测试","slug":"unit","permalink":"https://mirindalover.github.io/tags/unit/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo-github搭建个人博客","date":"19/06/2019","updated":"26/06/2019","comments":true,"path":"notes/hexo-github搭建个人博客.html","link":"","permalink":"https://mirindalover.github.io/notes/hexo-github搭建个人博客.html","excerpt":"","text":"前言免费搭建个人博客,可以使用github+hexo来完成 hexo 简洁的博客框架：配置简单,多种主题,可以本地浏览官网 前期准备 git工具Node.js hexo常用命令1234567891011//构建静态文件hexo g//开启服务器,默认http://localhost:4000///ctrl+c停止hexo s//部署到远端(github)hexo d//清除缓存hexo clean//创建文章,默认存放路径通过default_layout参数配置hexo n &#123;标题&#125; 创建本地博客 安装Hexo 1npm install -g hexo-cli 新建文件夹,命令行初始化hexo 12hexo initnpm install scaffolds文件夹：一些模板文件,后面会进行修改source文件夹：一些编译需要的,如文章themes文件夹：存放主题_config.yml文件：博客的主要配置package.json文件：一些依赖的插件 预览博客12hexo ghexo s 预览一下默认的博客public文件夹中即为生成的静态页面 改变主题在Hexo官网找到我们喜欢的主题,根据主题说明配置即可发布到github在github上创建仓库名字为：{名字}.github.io 的仓库在根目录的_config.yml文件进行配置,参考如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Sitetitle: xxx的博客 # 修改subtitle: description: author: xxxlanguage: zh-cntimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://xxx.github.io/ # 修改root: /permalink: :category/:title.html # 文章的urlpermalink_defaults: lang: en# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: 随笔 # 默认页面category_map: 随笔: notes #分类 tag_map: # 标签 Java: Java# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: xxx #修改# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/xxx #修改 为仓库地址 branch: master 重点是deploy属性,修改为自己的仓库地址也可以使用ssh来配置,也可以直接使用https的地址发布： 12hexo ghexo d .deploy_git文件即为与git仓库关联的文件夹 配置模板在scaffolds文件夹中,可以配置我们创建文章的模板post.md配置 123456789101112---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: xxxavatar: /images/xx.pngauthorDesc: categories: # 分类tags: #标签 - Javaphotos:- xxx.jpg #缩略图--- 这样我们创建文章的时候，会根据配置生成 关于标签我们在打开标签页面的时候可能为空原因是public\\tags目录下没有index.html 创建tags1hexo new page tags 生成source/tags/index.md文件配置index.md标签文件 123456---title: tagsdate: 2019-06-19 15:02:26type: \"tags\"layout: \"tags\"--- 根_config.yml添加tag_map列表文章中添加标签 关于插件安装插件都可通过官网来寻找如何配置的例如搜索插件插件配置 Tips 配置时冒号后面需要有空格 安装插件报错12xxxA@10.0.1 requires a peer of xxxB@&gt;= 4.12.1 but none isinstalled. You must install peer dependencies yourself. 我们可以直接根据提示，安装必要的依赖 1npm install xxxB@4. xxxB@10. --save-dev","author":"砖头","categories":[{"name":"随笔","slug":"notes","permalink":"https://mirindalover.github.io/categories/notes/"}],"tags":[{"name":"杂谈","slug":"talk","permalink":"https://mirindalover.github.io/tags/talk/"}]}]}